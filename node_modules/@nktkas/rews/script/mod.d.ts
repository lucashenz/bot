type UrlProvider = string | URL | (() => string | URL);
type ProtocolsProvider = string | string[] | undefined | (() => string | string[] | undefined);
type WebSocketSendData = string | ArrayBufferLike | Blob | ArrayBufferView;
type ReconnectingWebSocketErrorCode = "RECONNECTION_LIMIT" | "TERMINATED_BY_USER" | "UNKNOWN_ERROR";
/** Configuration options for the {@link ReconnectingWebSocket}. */
export interface ReconnectingWebSocketOptions {
    /**
     * Custom WebSocket constructor.
     * @default globalThis.WebSocket
     */
    WebSocket?: new (url: string | URL, protocols?: string | string[]) => WebSocket;
    /**
     * Maximum number of reconnection attempts.
     * @default 3
     */
    maxRetries?: number;
    /**
     * Maximum time in ms to wait for a connection to open.
     * Set to `null` to disable.
     * @default 10_000
     */
    connectionTimeout?: number | null;
    /**
     * Delay before reconnection in ms.
     * May be a number or a function that returns a number.
     * @param attempt - The current attempt number.
     * @default (attempt) => Math.min(~~(1 << attempt) * 150, 10_000); // Exponential backoff (max 10s)
     */
    reconnectionDelay?: number | ((attempt: number) => number);
}
interface ReconnectingWebSocketEventMap extends WebSocketEventMap {
    terminate: CustomEvent<ReconnectingWebSocketError>;
}
/** Error thrown when reconnection fails in {@link ReconnectingWebSocket}. */
export declare class ReconnectingWebSocketError extends Error {
    /**
     * Error code indicating the type of reconnection error:
     * - `RECONNECTION_LIMIT`: Maximum reconnection attempts reached
     * - `TERMINATED_BY_USER`: Closed via `close()` method
     * - `UNKNOWN_ERROR`: Unexpected failure during reconnection
     */
    code: ReconnectingWebSocketErrorCode;
    constructor(code: ReconnectingWebSocketErrorCode, cause?: unknown);
}
/**
 * A WebSocket with auto-reconnection logic. Fully compatible with standard WebSocket API.
 *
 * Features:
 * - Automatic reconnection with configurable max retries and delay.
 * - Buffers messages sent while disconnected and sends them upon reconnection.
 * - Re-applies event listeners after reconnection.
 * - Supports dynamic URL and protocols via functions.
 *
 * Additional properties and events:
 * - `isTerminated`: Indicates whether the instance has been permanently terminated.
 * - `terminationReason`: If terminated, provides the reason for termination.
 * - `terminationSignal`: AbortSignal that is aborted when the instance is permanently terminated.
 * - `terminate` event: Fired when the instance is permanently terminated.
 */
export declare class ReconnectingWebSocket implements WebSocket {
    protected _socket: WebSocket;
    protected _urlProvider: UrlProvider;
    protected _protocolsProvider: ProtocolsProvider;
    protected _listeners: {
        type: string;
        listener: EventListenerOrEventListenerObject;
        options?: boolean | AddEventListenerOptions;
        listenerProxy: EventListenerOrEventListenerObject;
    }[];
    protected _attempt: number;
    protected _messageBuffer: WebSocketSendData[];
    protected _abortController: AbortController;
    /** Indicates whether the instance has been permanently terminated. */
    get isTerminated(): boolean;
    /** If terminated, provides the reason for termination. */
    get terminationReason(): ReconnectingWebSocketError | undefined;
    /** AbortSignal that is aborted when the instance is permanently terminated. */
    get terminationSignal(): AbortSignal;
    /** Reconnection configuration options. */
    reconnectOptions: Required<ReconnectingWebSocketOptions>;
    constructor(url: UrlProvider, options?: ReconnectingWebSocketOptions);
    constructor(url: UrlProvider, protocols?: ProtocolsProvider, options?: ReconnectingWebSocketOptions);
    protected _createSocket(): void;
    protected _initInternalListeners(): void;
    protected _open: () => void;
    protected _close: () => Promise<void>;
    protected _cleanup(code: ConstructorParameters<typeof ReconnectingWebSocketError>[0], cause?: unknown): void;
    get url(): string;
    get readyState(): number;
    get bufferedAmount(): number;
    get extensions(): string;
    get protocol(): string;
    get binaryType(): BinaryType;
    set binaryType(value: BinaryType);
    readonly CONNECTING = 0;
    readonly OPEN = 1;
    readonly CLOSING = 2;
    readonly CLOSED = 3;
    static readonly CONNECTING = 0;
    static readonly OPEN = 1;
    static readonly CLOSING = 2;
    static readonly CLOSED = 3;
    get onclose(): ((this: WebSocket, ev: CloseEvent) => any) | null;
    set onclose(value: ((this: WebSocket, ev: CloseEvent) => any) | null);
    get onerror(): ((this: WebSocket, ev: Event) => any) | null;
    set onerror(value: ((this: WebSocket, ev: Event) => any) | null);
    get onmessage(): ((this: WebSocket, ev: MessageEvent<any>) => any) | null;
    set onmessage(value: ((this: WebSocket, ev: MessageEvent<any>) => any) | null);
    get onopen(): ((this: WebSocket, ev: Event) => any) | null;
    set onopen(value: ((this: WebSocket, ev: Event) => any) | null);
    /**
     * @param permanently - If `true`, the connection will be permanently closed. Default is `true`.
     */
    close(code?: number, reason?: string, permanently?: boolean): void;
    /**
     * @note If the connection is not open, the data will be buffered and sent when the connection is established.
     */
    send(data: WebSocketSendData): void;
    /**
     * @note The event listeners added via this method will be re-applied after reconnection. `once` option is supported.
     */
    addEventListener<K extends keyof ReconnectingWebSocketEventMap>(type: K, listener: ((this: ReconnectingWebSocket, ev: ReconnectingWebSocketEventMap[K]) => any) | {
        handleEvent: (event: ReconnectingWebSocketEventMap[K]) => any;
    }, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof ReconnectingWebSocketEventMap>(type: K, listener: ((this: ReconnectingWebSocket, ev: ReconnectingWebSocketEventMap[K]) => any) | {
        handleEvent: (event: ReconnectingWebSocketEventMap[K]) => any;
    }, options?: boolean | EventListenerOptions): void;
    dispatchEvent(event: Event): boolean;
}
export {};
//# sourceMappingURL=mod.d.ts.map