import * as P from 'micro-packed';
type IntIdxType = '' | '8' | '16' | '24' | '32' | '40' | '48' | '56' | '64' | '72' | '80' | '88' | '96' | '104' | '112' | '120' | '128' | '136' | '144' | '152' | '160' | '168' | '176' | '184' | '192' | '200' | '208' | '216' | '224' | '232' | '240' | '248' | '256';
type UintType = `uint${IntIdxType}`;
type IntType = `int${IntIdxType}`;
type NumberType = UintType | IntType;
type ByteIdxType = '' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12' | '13' | '14' | '15' | '16' | '17' | '18' | '19' | '20' | '21' | '22' | '23' | '24' | '25' | '26' | '27' | '28' | '29' | '30' | '31' | '32';
type ByteType = `bytes${ByteIdxType}`;
export type Writable<T> = T extends {} ? {
    -readonly [P in keyof T]: Writable<T[P]>;
} : T;
export type IsEmptyArray<T> = T extends ReadonlyArray<any> ? (T['length'] extends 0 ? true : false) : true;
export type ArrLike<T> = Array<T> | ReadonlyArray<T>;
export type Component<T extends string> = {
    readonly name?: string;
    readonly type: T;
};
export type NamedComponent<T extends string> = Component<T> & {
    readonly name: string;
};
export type BaseComponent = Component<string>;
export type Tuple<TC extends ArrLike<Component<string>>> = {
    readonly name?: string;
    readonly type: 'tuple';
    readonly components: TC;
};
export type MapTuple<T> = T extends ArrLike<Component<string> & {
    name: string;
}> ? {
    [K in T[number] as K['name']]: MapType<K>;
} : T extends ArrLike<Component<string>> ? {
    [K in keyof T]: T[K] extends BaseComponent ? MapType<T[K]> : unknown;
} : unknown;
export type MapType<T extends BaseComponent> = T extends Tuple<Array<Component<string>>> ? MapTuple<T['components']> : T extends {
    readonly type: 'tuple[]';
    readonly components: infer C extends Array<Component<string>>;
} ? MapTuple<C>[] : T extends Component<infer Type> ? GetType<Type> : unknown;
export type UnmapType<T> = T extends MapType<infer U> ? U : never;
export type ArgsType<T extends ReadonlyArray<any> | undefined> = IsEmptyArray<T> extends true ? undefined : T extends ReadonlyArray<any> ? T['length'] extends 1 ? MapType<T[0]> : MapTuple<T> : MapTuple<T>;
export type GetType<T extends string> = T extends `${infer Base}[]${infer Rest}` ? GetType<`${Base}${Rest}`>[] : T extends `${infer Base}[${number}]${infer Rest}` ? GetType<`${Base}${Rest}`>[] : T extends 'address' ? string : T extends 'string' ? string : T extends 'bool' ? boolean : T extends NumberType ? bigint : T extends ByteType ? Uint8Array : unknown;
export declare const ARRAY_RE: RegExp;
export declare function mapComponent<T extends BaseComponent>(c: T): P.CoderType<MapType<Writable<T>>>;
export declare function mapArgs<T extends ArrLike<Component<string>>>(args: T): P.CoderType<ArgsType<Writable<T>>>;
export {};
//# sourceMappingURL=abi-mapper.d.ts.map